<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Swiss Army Utils - Interactive Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 40px;
        }

        h1 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 2.5rem;
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1rem;
        }

        .function-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .function-card {
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            padding: 20px;
            background: #f9fafb;
            transition: all 0.3s ease;
        }

        .function-card:hover {
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.15);
        }

        .function-card h3 {
            color: #667eea;
            margin-bottom: 5px;
            font-size: 1.3rem;
        }

        .category {
            color: #999;
            font-size: 0.8rem;
            margin-bottom: 10px;
            font-style: italic;
        }

        .function-card p {
            color: #666;
            margin-bottom: 15px;
            font-size: 0.9rem;
        }

        .param {
            margin-bottom: 10px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
            font-size: 0.9rem;
        }

        .type {
            font-weight: normal;
            color: #888;
            font-size: 0.85rem;
        }

        input, textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9rem;
            font-family: 'Courier New', monospace;
            transition: border-color 0.3s ease;
        }

        input:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        button {
            background: #667eea;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: background 0.3s ease;
            width: 100%;
            margin-top: 10px;
        }

        button:hover {
            background: #5568d3;
        }

        button:active {
            transform: scale(0.98);
        }

        .output {
            margin-top: 15px;
            padding: 12px;
            background: #f0f4f8;
            border-left: 4px solid #667eea;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            white-space: pre-wrap;
            word-break: break-all;
            min-height: 40px;
        }

        .output.error {
            background: #fee;
            border-left-color: #e53e3e;
            color: #c53030;
        }

        .output.success {
            background: #e6fffa;
            border-left-color: #38b2ac;
            color: #234e52;
        }

        .github-link {
            display: inline-block;
            margin-top: 20px;
            color: #667eea;
            text-decoration: none;
            font-weight: 600;
        }

        .github-link:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üõ†Ô∏è Swiss Army Utils</h1>
        <p class="subtitle">Interactive playground for TypeScript utility functions</p>
        <p>Experiment with 32 utility functions below. Enter your input and see the results instantly!</p>
        <a href="https://github.com/mattiasahlsen/swiss-army-utils" class="github-link" target="_blank">
            View on GitHub ‚Üí
        </a>

        <div class="function-grid">

            <!-- isDeepEqual -->
            <div class="function-card">
                <h3>isDeepEqual</h3>
                <p class="category">compare</p>
                <p>Performs a deep equality comparison between two values.
Handles arrays, objects, dates, regular expressions, and primitive values.
Type-safe: only returns boolean when types match, otherwise returns void.</p>
                
            <div class="param">
                <label>a <span class="type">(T)</span>:</label>
                <input type="text" id="isDeepEqual-a" placeholder="The first value to compare." value="{ a: 1">
            </div>
            <div class="param">
                <label>b <span class="type">(U)</span>:</label>
                <input type="text" id="isDeepEqual-b" placeholder="The second value to compare." value="b: { c: 2 } }">
            </div>
                <button onclick="test_isDeepEqual()">Test isDeepEqual</button>
                <div id="isDeepEqual-output" class="output"></div>
            </div>

            <!-- createDependencyContainer -->
            <div class="function-card">
                <h3>createDependencyContainer</h3>
                <p class="category">dependency-injection</p>
                <p>Creates a dependency injection container for managing application dependencies.
Supports both synchronous and asynchronous dependencies with lazy initialization.
Containers can be extended to add new dependencies while maintaining type safety.</p>
                
            <div class="param">
                <label>options <span class="type">(Object)</span>:</label>
                <input type="text" id="createDependencyContainer-options" placeholder="Configuration for dependency creation." value="{
  createSyncDependencies: (">
            </div>
            <div class="param">
                <label>options.createSyncDependencies <span class="type">(function)</span>:</label>
                <input type="text" id="createDependencyContainer-options.createSyncDependencies" placeholder="Optional function that creates synchronous dependencies." value="">
            </div>
            <div class="param">
                <label>options.createAsyncDependencies <span class="type">(function)</span>:</label>
                <input type="text" id="createDependencyContainer-options.createAsyncDependencies" placeholder="Optional function that creates asynchronous dependencies." value="">
            </div>
                <button onclick="test_createDependencyContainer()">Test createDependencyContainer</button>
                <div id="createDependencyContainer-output" class="output"></div>
            </div>

            <!-- getErrorMessage -->
            <div class="function-card">
                <h3>getErrorMessage</h3>
                <p class="category">error</p>
                <p>Extracts an error message from an unknown error value.
Handles Error objects, strings, objects, and other types gracefully.</p>
                
            <div class="param">
                <label>error <span class="type">(unknown)</span>:</label>
                <input type="text" id="getErrorMessage-error" placeholder="The error value to extract a message from." value="new Error(Something went wrong">
            </div>
                <button onclick="test_getErrorMessage()">Test getErrorMessage</button>
                <div id="getErrorMessage-output" class="output"></div>
            </div>

            <!-- filterUnique -->
            <div class="function-card">
                <h3>filterUnique</h3>
                <p class="category">filter</p>
                <p>Filters an array to keep only unique items based on a key extraction function.
When duplicate keys are found, the last occurrence is kept.</p>
                
            <div class="param">
                <label>items <span class="type">(Array.<T>)</span>:</label>
                <input type="text" id="filterUnique-items" placeholder="The array of items to filter." value="items">
            </div>
            <div class="param">
                <label>getKey <span class="type">(function)</span>:</label>
                <input type="text" id="filterUnique-getKey" placeholder="Function that extracts a unique key from each item." value="(item">
            </div>
                <button onclick="test_filterUnique()">Test filterUnique</button>
                <div id="filterUnique-output" class="output"></div>
            </div>

            <!-- isDefined -->
            <div class="function-card">
                <h3>isDefined</h3>
                <p class="category">filter</p>
                <p>Type guard that checks if a value is neither undefined nor null.
This is useful for filtering arrays and narrowing types in TypeScript.</p>
                
            <div class="param">
                <label>value <span class="type">(T | undefined | null)</span>:</label>
                <input type="text" id="isDefined-value" placeholder="The value to check for being defined." value="maybeValue">
            </div>
                <button onclick="test_isDefined()">Test isDefined</button>
                <div id="isDefined-output" class="output"></div>
            </div>

            <!-- findOrThrow -->
            <div class="function-card">
                <h3>findOrThrow</h3>
                <p class="category">find</p>
                <p>Finds the first item in the array that matches the predicate, throwing an error if no match is found.</p>
                
            <div class="param">
                <label>arr <span class="type">(Array.<T>)</span>:</label>
                <input type="text" id="findOrThrow-arr" placeholder="The array to search." value="numbers">
            </div>
            <div class="param">
                <label>predicate <span class="type">(function)</span>:</label>
                <input type="text" id="findOrThrow-predicate" placeholder="Function to test each item. Returns true for the item to be returned." value="n => n === 2">
            </div>
                <button onclick="test_findOrThrow()">Test findOrThrow</button>
                <div id="findOrThrow-output" class="output"></div>
            </div>

            <!-- firstOrThrow -->
            <div class="function-card">
                <h3>firstOrThrow</h3>
                <p class="category">find</p>
                <p>Returns the first item in the array, throwing an error if the array is empty.</p>
                
            <div class="param">
                <label>items <span class="type">(Array.<T>)</span>:</label>
                <input type="text" id="firstOrThrow-items" placeholder="The array to get the first item from." value="items">
            </div>
                <button onclick="test_firstOrThrow()">Test firstOrThrow</button>
                <div id="firstOrThrow-output" class="output"></div>
            </div>

            <!-- indexOrThrow -->
            <div class="function-card">
                <h3>indexOrThrow</h3>
                <p class="category">find</p>
                <p>Returns the item at the specified index in the array, throwing an error if the index is out of bounds.</p>
                
            <div class="param">
                <label>items <span class="type">(Array.<T>)</span>:</label>
                <input type="text" id="indexOrThrow-items" placeholder="The array to get the item from." value="items">
            </div>
            <div class="param">
                <label>index <span class="type">(number)</span>:</label>
                <input type="text" id="indexOrThrow-index" placeholder="The index of the item to retrieve." value="1">
            </div>
                <button onclick="test_indexOrThrow()">Test indexOrThrow</button>
                <div id="indexOrThrow-output" class="output"></div>
            </div>

            <!-- makeThrottled -->
            <div class="function-card">
                <h3>makeThrottled</h3>
                <p class="category">functions</p>
                <p>Creates a throttled version of a function that enforces a minimum delay between executions.
Multiple calls made during the delay period will share the same promise and return the same result.
After the delay period, subsequent calls will trigger a new execution.</p>
                
            <div class="param">
                <label>options <span class="type">(Object)</span>:</label>
                <input type="text" id="makeThrottled-options" placeholder="Configuration object." value="{ minDelay: 1000 }">
            </div>
            <div class="param">
                <label>options.minDelay <span class="type">(number)</span>:</label>
                <input type="text" id="makeThrottled-options.minDelay" placeholder="Minimum delay in milliseconds between function executions." value="fetchData">
            </div>
            <div class="param">
                <label>fn <span class="type">(function)</span>:</label>
                <input type="text" id="makeThrottled-fn" placeholder="The function to throttle. Can be synchronous or asynchronous." value="">
            </div>
                <button onclick="test_makeThrottled()">Test makeThrottled</button>
                <div id="makeThrottled-output" class="output"></div>
            </div>

            <!-- sleep -->
            <div class="function-card">
                <h3>sleep</h3>
                <p class="category">functions</p>
                <p>Asynchronously pauses execution for a specified duration.
Returns a promise that resolves after the given number of milliseconds.</p>
                
            <div class="param">
                <label>ms <span class="type">(number)</span>:</label>
                <input type="text" id="sleep-ms" placeholder="Duration in milliseconds to sleep." value="1000">
            </div>
                <button onclick="test_sleep()">Test sleep</button>
                <div id="sleep-output" class="output"></div>
            </div>

            <!-- asTuple -->
            <div class="function-card">
                <h3>asTuple</h3>
                <p class="category">map-reduce</p>
                <p>Type-level function that ensures the input array is treated as a tuple type.
This is useful for preserving exact array literal types.</p>
                
            <div class="param">
                <label>arr <span class="type">(T)</span>:</label>
                <input type="text" id="asTuple-arr" placeholder="The array to treat as a tuple." value="[1">
            </div>
                <button onclick="test_asTuple()">Test asTuple</button>
                <div id="asTuple-output" class="output"></div>
            </div>

            <!-- asyncFlatMap -->
            <div class="function-card">
                <h3>asyncFlatMap</h3>
                <p class="category">map-reduce</p>
                <p>Asynchronously maps over an array or async iterable and flattens the results.
Equivalent to calling asyncMap followed by Array.flat().
The mapping is performed sequentially to maintain order.</p>
                
            <div class="param">
                <label>array <span class="type">(Array.<T> | AsyncIterable.<T>)</span>:</label>
                <input type="text" id="asyncFlatMap-array" placeholder="The array or async iterable to map over." value="words">
            </div>
            <div class="param">
                <label>mapper <span class="type">(function)</span>:</label>
                <input type="text" id="asyncFlatMap-mapper" placeholder="Async function that transforms each item. Receives the item and its index." value="async (word">
            </div>
                <button onclick="test_asyncFlatMap()">Test asyncFlatMap</button>
                <div id="asyncFlatMap-output" class="output"></div>
            </div>

            <!-- asyncMap -->
            <div class="function-card">
                <h3>asyncMap</h3>
                <p class="category">map-reduce</p>
                <p>Asynchronously maps over an array or async iterable, applying an async mapper function to each item.
The mapping is performed sequentially (not in parallel) to maintain order and avoid overwhelming resources.</p>
                
            <div class="param">
                <label>iterator <span class="type">(Array.<T> | AsyncIterable.<T>)</span>:</label>
                <input type="text" id="asyncMap-iterator" placeholder="The array or async iterable to map over." value="numbers">
            </div>
            <div class="param">
                <label>mapper <span class="type">(function)</span>:</label>
                <input type="text" id="asyncMap-mapper" placeholder="Async function that transforms each item. Receives the item and its index." value="async (n">
            </div>
                <button onclick="test_asyncMap()">Test asyncMap</button>
                <div id="asyncMap-output" class="output"></div>
            </div>

            <!-- asyncReduce -->
            <div class="function-card">
                <h3>asyncReduce</h3>
                <p class="category">map-reduce</p>
                <p>Asynchronously reduces an array to a single value using an async reducer function.
The reduction is performed sequentially, processing one item at a time.</p>
                
            <div class="param">
                <label>items <span class="type">(Array.<Item>)</span>:</label>
                <input type="text" id="asyncReduce-items" placeholder="The array to reduce." value="numbers">
            </div>
            <div class="param">
                <label>reducer <span class="type">(function)</span>:</label>
                <input type="text" id="asyncReduce-reducer" placeholder="Async function that combines the accumulator with each item." value="async (total">
            </div>
            <div class="param">
                <label>initialResult <span class="type">(Result)</span>:</label>
                <input type="text" id="asyncReduce-initialResult" placeholder="The initial value for the accumulator." value="num">
            </div>
                <button onclick="test_asyncReduce()">Test asyncReduce</button>
                <div id="asyncReduce-output" class="output"></div>
            </div>

            <!-- batchArray -->
            <div class="function-card">
                <h3>batchArray</h3>
                <p class="category">map-reduce</p>
                <p>Splits an array into smaller arrays (batches) of a specified size.
Each batch will contain at most `batchSize` items.</p>
                
            <div class="param">
                <label>array <span class="type">(Array.<T>)</span>:</label>
                <input type="text" id="batchArray-array" placeholder="The array to split into batches." value="[1">
            </div>
            <div class="param">
                <label>batchSize <span class="type">(number)</span>:</label>
                <input type="text" id="batchArray-batchSize" placeholder="The maximum number of items per batch." value="2">
            </div>
                <button onclick="test_batchArray()">Test batchArray</button>
                <div id="batchArray-output" class="output"></div>
            </div>

            <!-- batchArrayByWeights -->
            <div class="function-card">
                <h3>batchArrayByWeights</h3>
                <p class="category">map-reduce</p>
                <p>Splits an array into smaller arrays (batches) based on weighted sizes.
Items are grouped into batches where the total weight doesn't exceed the specified batch size.</p>
                
            <div class="param">
                <label>items <span class="type">(Array.<T>)</span>:</label>
                <input type="text" id="batchArrayByWeights-items" placeholder="The array to split into batches." value="items">
            </div>
            <div class="param">
                <label>batchSize <span class="type">(number)</span>:</label>
                <input type="text" id="batchArrayByWeights-batchSize" placeholder="The maximum total weight allowed per batch." value="5">
            </div>
            <div class="param">
                <label>getWeight <span class="type">(function)</span>:</label>
                <input type="text" id="batchArrayByWeights-getWeight" placeholder="Function to calculate the weight of each item." value="item => item.length">
            </div>
                <button onclick="test_batchArrayByWeights()">Test batchArrayByWeights</button>
                <div id="batchArrayByWeights-output" class="output"></div>
            </div>

            <!-- batchAsyncIterableByWeights -->
            <div class="function-card">
                <h3>batchAsyncIterableByWeights</h3>
                <p class="category">map-reduce</p>
                <p>Asynchronously splits an async iterable into batches based on weighted sizes.
Items are grouped into batches where the total weight doesn't exceed the specified batch size.
This is an async generator that yields batches as they are formed.</p>
                
            <div class="param">
                <label>items <span class="type">(AsyncIterable.<T>)</span>:</label>
                <input type="text" id="batchAsyncIterableByWeights-items" placeholder="The async iterable to split into batches." value="generateItems(">
            </div>
            <div class="param">
                <label>batchSize <span class="type">(number)</span>:</label>
                <input type="text" id="batchAsyncIterableByWeights-batchSize" placeholder="The maximum total weight allowed per batch." value="">
            </div>
            <div class="param">
                <label>getWeight <span class="type">(function)</span>:</label>
                <input type="text" id="batchAsyncIterableByWeights-getWeight" placeholder="Function to calculate the weight of each item." value="">
            </div>
                <button onclick="test_batchAsyncIterableByWeights()">Test batchAsyncIterableByWeights</button>
                <div id="batchAsyncIterableByWeights-output" class="output"></div>
            </div>

            <!-- groupBy -->
            <div class="function-card">
                <h3>groupBy</h3>
                <p class="category">map-reduce</p>
                <p>Groups the elements of an array based on a key derived from each element.</p>
                
            <div class="param">
                <label>array <span class="type">(Array.<T>)</span>:</label>
                <input type="text" id="groupBy-array" placeholder="The array to be grouped." value="data">
            </div>
            <div class="param">
                <label>getKey <span class="type">(function)</span>:</label>
                <input type="text" id="groupBy-getKey" placeholder="A function that derives the key from each element." value="item => item.category">
            </div>
            <div class="param">
                <label>initialValue <span class="type">(Record.<Key, Array.<T>>)</span>:</label>
                <input type="text" id="groupBy-initialValue" placeholder="An initial value for the grouped result." value="{}">
            </div>
                <button onclick="test_groupBy()">Test groupBy</button>
                <div id="groupBy-output" class="output"></div>
            </div>

            <!-- pluckIds -->
            <div class="function-card">
                <h3>pluckIds</h3>
                <p class="category">map-reduce</p>
                <p>Extracts unique IDs from an array of objects using an ID getter function.
The function flattens nested arrays up to 10 levels deep, filters out null/undefined values,
and returns a deduplicated array of IDs.</p>
                
            <div class="param">
                <label>items <span class="type">(Array.<T>)</span>:</label>
                <input type="text" id="pluckIds-items" placeholder="The array of objects to extract IDs from." value="users">
            </div>
            <div class="param">
                <label>idGetter <span class="type">(function)</span>:</label>
                <input type="text" id="pluckIds-idGetter" placeholder="Function that extracts the ID(s) from each item. Can return single values or nested arrays." value="user => user.id">
            </div>
                <button onclick="test_pluckIds()">Test pluckIds</button>
                <div id="pluckIds-output" class="output"></div>
            </div>

            <!-- roundToDecimals -->
            <div class="function-card">
                <h3>roundToDecimals</h3>
                <p class="category">map-reduce</p>
                <p></p>
                
            <div class="param">
                <label>value <span class="type">(number)</span>:</label>
                <input type="text" id="roundToDecimals-value" placeholder="The value to round." value="3.14159">
            </div>
            <div class="param">
                <label>decimals <span class="type">(number)</span>:</label>
                <input type="text" id="roundToDecimals-decimals" placeholder="The number of decimal places to round to." value="2">
            </div>
                <button onclick="test_roundToDecimals()">Test roundToDecimals</button>
                <div id="roundToDecimals-output" class="output"></div>
            </div>

            <!-- stringToNumber -->
            <div class="function-card">
                <h3>stringToNumber</h3>
                <p class="category">map-reduce</p>
                <p>Safely converts a string to a number with validation.
Throws an error if the string cannot be converted to a valid finite number.</p>
                
            <div class="param">
                <label>value <span class="type">(string)</span>:</label>
                <input type="text" id="stringToNumber-value" placeholder="The string to convert to a number." value="123">
            </div>
                <button onclick="test_stringToNumber()">Test stringToNumber</button>
                <div id="stringToNumber-output" class="output"></div>
            </div>

            <!-- toSorted -->
            <div class="function-card">
                <h3>toSorted</h3>
                <p class="category">map-reduce</p>
                <p>Sorts an array by a key extracted from each item, returning a new sorted array.
The original array is not modified.</p>
                
            <div class="param">
                <label>array <span class="type">(Array.<T>)</span>:</label>
                <input type="text" id="toSorted-array" placeholder="The array to sort." value="users">
            </div>
            <div class="param">
                <label>getKey <span class="type">(function)</span>:</label>
                <input type="text" id="toSorted-getKey" placeholder="Function to extract the sort key from each item." value="user => user.name">
            </div>
            <div class="param">
                <label>order <span class="type">(string)</span>:</label>
                <input type="text" id="toSorted-order" placeholder="Sort order, either 'asc' for ascending or 'desc' for descending. Defaults to 'asc'." value="">
            </div>
                <button onclick="test_toSorted()">Test toSorted</button>
                <div id="toSorted-output" class="output"></div>
            </div>

            <!-- createRange -->
            <div class="function-card">
                <h3>createRange</h3>
                <p class="category">misc</p>
                <p>Creates an array of consecutive integers from 0 to length-1.</p>
                
            <div class="param">
                <label>length <span class="type">(number)</span>:</label>
                <input type="text" id="createRange-length" placeholder="The number of elements in the range. Must be non-negative." value="5">
            </div>
                <button onclick="test_createRange()">Test createRange</button>
                <div id="createRange-output" class="output"></div>
            </div>

            <!-- createSingletonAsync -->
            <div class="function-card">
                <h3>createSingletonAsync</h3>
                <p class="category">misc</p>
                <p>Creates an async singleton that lazily fetches and caches a value.
The cached value is validated before each use and refreshed if invalid.
Handles concurrent calls by ensuring only one fetch happens at a time.</p>
                
            <div class="param">
                <label>options <span class="type">(Object)</span>:</label>
                <input type="text" id="createSingletonAsync-options" placeholder="Configuration object." value="">
            </div>
            <div class="param">
                <label>options.getValue <span class="type">(function)</span>:</label>
                <input type="text" id="createSingletonAsync-options.getValue" placeholder="Function that fetches the value asynchronously." value="">
            </div>
            <div class="param">
                <label>options.isValid <span class="type">(function)</span>:</label>
                <input type="text" id="createSingletonAsync-options.isValid" placeholder="Function that checks if the cached value is still valid." value="">
            </div>
                <button onclick="test_createSingletonAsync()">Test createSingletonAsync</button>
                <div id="createSingletonAsync-output" class="output"></div>
            </div>

            <!-- createSingletonSync -->
            <div class="function-card">
                <h3>createSingletonSync</h3>
                <p class="category">misc</p>
                <p>Creates a synchronous singleton that lazily fetches and caches a value.
The cached value is validated before each use and refreshed if invalid.</p>
                
            <div class="param">
                <label>options <span class="type">(Object)</span>:</label>
                <input type="text" id="createSingletonSync-options" placeholder="Configuration object." value="{
  getValue: (">
            </div>
            <div class="param">
                <label>options.getValue <span class="type">(function)</span>:</label>
                <input type="text" id="createSingletonSync-options.getValue" placeholder="Function that fetches the value synchronously." value="">
            </div>
            <div class="param">
                <label>options.isValid <span class="type">(function)</span>:</label>
                <input type="text" id="createSingletonSync-options.isValid" placeholder="Function that checks if the cached value is still valid." value="">
            </div>
                <button onclick="test_createSingletonSync()">Test createSingletonSync</button>
                <div id="createSingletonSync-output" class="output"></div>
            </div>

            <!-- callInOrderWithErrorHandling -->
            <div class="function-card">
                <h3>callInOrderWithErrorHandling</h3>
                <p class="category">misc</p>
                <p>Calls all handlers in order, collecting errors and throwing them at the end.
If only one error occurs, throws that error directly.
If multiple errors occur, throws an AggregateError.</p>
                
            <div class="param">
                <label>handlers <span class="type">(Set.<Handler.<TParams>>)</span>:</label>
                <input type="text" id="callInOrderWithErrorHandling-handlers" placeholder="Set of handler functions to call." value="">
            </div>
            <div class="param">
                <label>params <span class="type">(TParams)</span>:</label>
                <input type="text" id="callInOrderWithErrorHandling-params" placeholder="Parameters to pass to each handler." value="">
            </div>
                <button onclick="test_callInOrderWithErrorHandling()">Test callInOrderWithErrorHandling</button>
                <div id="callInOrderWithErrorHandling-output" class="output"></div>
            </div>

            <!-- createSubject -->
            <div class="function-card">
                <h3>createSubject</h3>
                <p class="category">misc</p>
                <p>Creates a subject (observable) for event-driven programming.
Allows subscribers to listen for events and emit events to all subscribers.
Handlers are called in order, and all handlers are executed even if some fail.</p>
                
                <button onclick="test_createSubject()">Test createSubject</button>
                <div id="createSubject-output" class="output"></div>
            </div>

            <!-- mergeSubjects -->
            <div class="function-card">
                <h3>mergeSubjects</h3>
                <p class="category">misc</p>
                <p>Merges multiple subjects into a single subscribable subject.
A handler subscribed to the merged subject will receive events from all source subjects.
Note: The merged subject cannot emit events, only subscribe to them.</p>
                
            <div class="param">
                <label>subjects <span class="type">(Array.<Subject.<THandlerParams>>)</span>:</label>
                <input type="text" id="mergeSubjects-subjects" placeholder="Array of subjects to merge." value="[subject1">
            </div>
                <button onclick="test_mergeSubjects()">Test mergeSubjects</button>
                <div id="mergeSubjects-output" class="output"></div>
            </div>

            <!-- filterObjectFields -->
            <div class="function-card">
                <h3>filterObjectFields</h3>
                <p class="category">object</p>
                <p>Creates a new object containing only the entries that pass the filter function.
The filter function receives both the value and key for each entry.</p>
                
            <div class="param">
                <label>object <span class="type">(Record.<string, Value>)</span>:</label>
                <input type="text" id="filterObjectFields-object" placeholder="The object to filter." value="scores">
            </div>
            <div class="param">
                <label>filter <span class="type">(function)</span>:</label>
                <input type="text" id="filterObjectFields-filter" placeholder="Function that tests each value and key. Returns true to keep the entry." value="(score">
            </div>
                <button onclick="test_filterObjectFields()">Test filterObjectFields</button>
                <div id="filterObjectFields-output" class="output"></div>
            </div>

            <!-- mapObjectFields -->
            <div class="function-card">
                <h3>mapObjectFields</h3>
                <p class="category">object</p>
                <p>Transforms an object by mapping over its key-value pairs.
The mapping function receives each key-value pair as a tuple and returns a new tuple.</p>
                
            <div class="param">
                <label>obj <span class="type">(Record.<string, TMapped>)</span>:</label>
                <input type="text" id="mapObjectFields-obj" placeholder="The object to transform." value="prices">
            </div>
            <div class="param">
                <label>mapFn <span class="type">(function)</span>:</label>
                <input type="text" id="mapObjectFields-mapFn" placeholder="Function that maps each [key, value] tuple to a new [key, value] tuple." value="([key">
            </div>
                <button onclick="test_mapObjectFields()">Test mapObjectFields</button>
                <div id="mapObjectFields-output" class="output"></div>
            </div>

            <!-- omit -->
            <div class="function-card">
                <h3>omit</h3>
                <p class="category">object</p>
                <p>Creates a new object by excluding specified keys from an existing object.
Returns a copy of the object without the omitted properties.</p>
                
            <div class="param">
                <label>obj <span class="type">(Object)</span>:</label>
                <input type="text" id="omit-obj" placeholder="The source object to omit from." value="user">
            </div>
            <div class="param">
                <label>keys <span class="type">(string)</span>:</label>
                <input type="text" id="omit-keys" placeholder="Keys to omit from the object. Can be provided as separate arguments or arrays." value="password">
            </div>
                <button onclick="test_omit()">Test omit</button>
                <div id="omit-output" class="output"></div>
            </div>

            <!-- pick -->
            <div class="function-card">
                <h3>pick</h3>
                <p class="category">object</p>
                <p>Creates a new object by picking specified keys from an existing object.
Only includes properties that exist in the source object.</p>
                
            <div class="param">
                <label>obj <span class="type">(Object)</span>:</label>
                <input type="text" id="pick-obj" placeholder="The source object to pick from." value="user">
            </div>
            <div class="param">
                <label>keys <span class="type">(Array)</span>:</label>
                <input type="text" id="pick-keys" placeholder="Array of keys to pick from the object." value="['id'">
            </div>
                <button onclick="test_pick()">Test pick</button>
                <div id="pick-output" class="output"></div>
            </div>
        </div>
    </div>

    <script>
        // Utility function implementations (embedded from source)
        // isDeepEqual
        /**
 * Performs a deep equality comparison between two values.
 * Handles arrays, objects, dates, regular expressions, and primitive values.
 * Type-safe: only returns boolean when types match, otherwise returns void.
 *
 * @param {T} a - The first value to compare.
 * @param {U} b - The second value to compare.
 * @returns {boolean | void} True if values are deeply equal, false otherwise. Returns void if types don't match.
 *
 * @example
 * ```ts
 * isDeepEqual({ a: 1, b: { c: 2 } }, { a: 1, b: { c: 2 } }); // returns true
 * isDeepEqual([1, 2, 3], [1, 2, 3]); // returns true
 * isDeepEqual(new Date('2024-01-01'), new Date('2024-01-01')); // returns true
 * isDeepEqual({ a: 1 }, { a: 2 }); // returns false
 * ```
 */
function isDeepEqual(a, b) {
    return _isDeepEqual(a, b);
}
function _isDeepEqual(a, b) {
    if (a === b)
        return true;
    if (Number.isNaN(a) && Number.isNaN(b))
        return true;
    if (typeof a !== 'object' || typeof b !== 'object')
        return false;
    if (Array.isArray(a) !== Array.isArray(b))
        return false;
    if (Array.isArray(a)) {
        if (a.length !== b.length)
            return false;
        for (let i = 0; i < a.length; i++) {
            if (!_isDeepEqual(a[i], b[i]))
                return false;
        }
        return true;
    }
    if (a instanceof Date && b instanceof Date) {
        return (a.getTime() === b.getTime() &&
            a.getTimezoneOffset() === b.getTimezoneOffset());
    }
    if (a instanceof RegExp && b instanceof RegExp) {
        return a.source === b.source && a.flags === b.flags;
    }
    if (a.constructor !== b.constructor)
        return false;
    const keysA = Object.keys(a);
    const keysB = Object.keys(b);
    if (keysA.length !== keysB.length)
        return false;
    for (const key of keysA) {
        if (!_isDeepEqual(a[key], b[key]))
            return false;
    }
    return true;
}


        // createDependencyContainer - source not found

        // getErrorMessage
        /**
 * Extracts an error message from an unknown error value.
 * Handles Error objects, strings, objects, and other types gracefully.
 *
 * @param {unknown} error - The error value to extract a message from.
 * @returns {string} A string representation of the error message.
 *
 * @example
 * ```ts
 * getErrorMessage(new Error('Something went wrong')); // returns 'Something went wrong'
 * getErrorMessage('Error string'); // returns 'Error string'
 * getErrorMessage({ code: 404 }); // returns '{"code":404}'
 * getErrorMessage(null); // returns 'An unknown error occurred'
 * ```
 */
function getErrorMessage(error) {
    if (error instanceof Error) {
        return error.message;
    }
    else if (typeof error === 'string') {
        return error;
    }
    else if (typeof error === 'object' && error !== null) {
        return JSON.stringify(error);
    }
    return 'An unknown error occurred';
}


        // filterUnique
        /**
 * Filters an array to keep only unique items based on a key extraction function.
 * When duplicate keys are found, the last occurrence is kept.
 *
 * @param {T[]} items - The array of items to filter.
 * @param {function} getKey - Function that extracts a unique key from each item.
 * @returns {Array<T>} An array containing only unique items based on the extracted keys.
 *
 * @example
 * ```ts
 * const items = [
 *   { id: '1', name: 'a' },
 *   { id: '2', name: 'b' },
 *   { id: '1', name: 'c' }
 * ];
 * filterUnique(items, (item) => item.id);
 * // returns [{ id: '1', name: 'c' }, { id: '2', name: 'b' }]
 * ```
 */
function filterUnique(items, getKey) {
    const map = new Map();
    items.forEach((item) => map.set(getKey(item), item));
    return Array.from(map.values());
}


        // isDefined
        /**
 * Type guard that checks if a value is neither undefined nor null.
 * This is useful for filtering arrays and narrowing types in TypeScript.
 *
 * @param {T | undefined | null} value - The value to check for being defined.
 * @returns {boolean} True if the value is not undefined and not null, false otherwise.
 *
 * @example
 * ```ts
 * const values = [1, null, 2, undefined, 3];
 * const definedValues = values.filter(isDefined);
 * // returns [1, 2, 3]
 *
 * const maybeValue: string | null | undefined = getOptionalValue();
 * if (isDefined(maybeValue)) {
 *   // TypeScript knows maybeValue is string here
 *   console.log(maybeValue.toUpperCase());
 * }
 * ```
 */
function isDefined(value) {
    return value !== undefined && value !== null;
}


        // findOrThrow
        /**
 * Finds the first item in the array that matches the predicate, throwing an error if no match is found.
 *
 * @param {T[]} arr - The array to search.
 * @param {function} predicate - Function to test each item. Returns true for the item to be returned.
 * @returns {T} The first item that satisfies the predicate.
 * @throws {Error} If no item matches the predicate.
 *
 * @example
 * ```ts
 * const numbers = [1, 2, 3, 4];
 *
 * findOrThrow(numbers, n => n === 2); // returns 2
 * findOrThrow(numbers, n => n > 2); // returns 3
 * findOrThrow(numbers, n => n === 5); // throws Error: Item not found
 * ```
 */
function findOrThrow(arr, predicate) {
    return arr.find(predicate) ?? raise('Item not found');
}


        // firstOrThrow
        /**
 * Returns the first item in the array, throwing an error if the array is empty.
 *
 * @param {T[]} items - The array to get the first item from.
 * @returns {T} The first item in the array.
 * @throws {Error} If the array is empty.
 *
 * @example
 * ```ts
 * const items = ['a', 'b', 'c'];
 *
 * firstOrThrow(items); // returns 'a'
 * firstOrThrow([]); // throws Error: No item found at index 0
 * ```
 */
function firstOrThrow(items) {
    return indexOrThrow(items, 0);
}


        // indexOrThrow
        /**
 * Returns the item at the specified index in the array, throwing an error if the index is out of bounds.
 *
 * @param {T[]} items - The array to get the item from.
 * @param {number} index - The index of the item to retrieve.
 * @returns {T} The item at the specified index.
 * @throws {Error} If no item exists at the specified index.
 *
 * @example
 * ```ts
 * const items = ['a', 'b', 'c'];
 *
 * indexOrThrow(items, 1); // returns 'b'
 * indexOrThrow(items, 3); // throws Error: No item found at index 3
 * indexOrThrow(items, -1); // throws Error: No item found at index -1
 * ```
 */
function indexOrThrow(items, index) {
    const item = items[index];
    if (item === undefined) {
        throw new Error(`No item found at index ${index}`);
    }
    return item;
}


        // makeThrottled
        /**
 * Creates a throttled version of a function that enforces a minimum delay between executions.
 * Multiple calls made during the delay period will share the same promise and return the same result.
 * After the delay period, subsequent calls will trigger a new execution.
 *
 * @param {Object} options - Configuration object.
 * @param {number} options.minDelay - Minimum delay in milliseconds between function executions.
 * @param {function} fn - The function to throttle. Can be synchronous or asynchronous.
 * @returns {function} A throttled function that returns a promise. If multiple calls are made within the delay period,
 *          they will all receive the same promise and result.
 *
 * @example
 * ```ts
 * // Throttle an API call to at most once per second
 * const fetchData = () => fetch('/api/data').then(r => r.json());
 * const throttledFetch = makeThrottled({ minDelay: 1000 }, fetchData);
 *
 * // First call executes immediately
 * const result1 = await throttledFetch();
 *
 * // Calls within 1 second share the same promise
 * const promise2 = throttledFetch();
 * const promise3 = throttledFetch();
 * // promise2 === promise3
 *
 * // After 1 second delay, new call triggers another execution
 * await sleep(1100);
 * const result2 = await throttledFetch(); // New execution
 * ```
 */
function makeThrottled({ minDelay }, fn) {
    let nextCall = null;
    let sleeping = null;
    const callFunc = async () => {
        if (sleeping) {
            await sleeping;
        }
        sleeping = sleep(minDelay);
        return await fn();
    };
    return (() => {
        if (nextCall) {
            return nextCall;
        }
        nextCall = callFunc().finally(() => {
            nextCall = null;
        });
        return nextCall;
    });
}


        // sleep
        /**
 * Asynchronously pauses execution for a specified duration.
 * Returns a promise that resolves after the given number of milliseconds.
 *
 * @param {number} ms - Duration in milliseconds to sleep.
 * @returns {Promise<void>} A promise that resolves after the specified delay.
 *
 * @example
 * ```ts
 * // Sleep for 1 second
 * await sleep(1000);
 *
 * // Use in a loop with delays
 * for (let i = 0; i < 5; i++) {
 *   console.log(i);
 *   await sleep(500);
 * }
 * ```
 */
function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}


        // asTuple
        /**
 * Type-level function that ensures the input array is treated as a tuple type.
 * This is useful for preserving exact array literal types.
 *
 * @param {T} arr - The array to treat as a tuple.
 * @returns {T} The same array, but with tuple type preservation.
 *
 * @example
 * ```ts
 * const tuple = asTuple([1, 2, 3]); // Type: [1, 2, 3]
 * const array = [1, 2, 3]; // Type: number[]
 * ```
 */
function asTuple(arr) {
    return arr;
}


        // asyncFlatMap
        /**
 * Asynchronously maps over an array or async iterable and flattens the results.
 * Equivalent to calling asyncMap followed by Array.flat().
 * The mapping is performed sequentially to maintain order.
 *
 * @param {T[] | AsyncIterable<T>} array - The array or async iterable to map over.
 * @param {function} mapper - Async function that transforms each item. Receives the item and its index.
 * @returns {Promise<Array>} A promise that resolves to a flattened array of mapped results.
 *
 * @example
 * ```ts
 * const words = ['hello', 'world'];
 * const letters = await asyncFlatMap(words, async (word, index) => {
 *   await sleep(100); // Simulate async operation
 *   return word.split('');
 * });
 * // returns ['h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd']
 *
 * // Without asyncFlatMap, you'd need:
 * // const mapped = await asyncMap(words, mapper);
 * // const flattened = mapped.flat();
 * ```
 */
async function asyncFlatMap(array, mapper) {
    const result = await asyncMap(array, mapper);
    return result.flat();
}


        // asyncMap
        /**
 * Asynchronously maps over an array or async iterable, applying an async mapper function to each item.
 * The mapping is performed sequentially (not in parallel) to maintain order and avoid overwhelming resources.
 *
 * @param {T[] | AsyncIterable<T>} iterator - The array or async iterable to map over.
 * @param {function} mapper - Async function that transforms each item. Receives the item and its index.
 * @returns {Promise<R[]>} A promise that resolves to an array of mapped results.
 *
 * @example
 * ```ts
 * // With array
 * const numbers = [1, 2, 3];
 * const doubled = await asyncMap(numbers, async (n, index) => {
 *   await sleep(100); // Simulate async operation
 *   return n * 2;
 * });
 * // returns [2, 4, 6]
 *
 * // With async iterable
 * async function* generateNumbers() {
 *   yield 1; yield 2; yield 3;
 * }
 * const result = await asyncMap(generateNumbers(), async (n) => n * 2);
 * // returns [2, 4, 6]
 * ```
 */
async function asyncMap(iterator, mapper) {
    const result = [];
    if (Array.isArray(iterator)) {
        for (const [index, item] of iterator.entries()) {
            result.push(await mapper(item, index));
        }
    }
    else {
        let index = 0;
        for await (const item of iterator) {
            result.push(await mapper(item, index++));
        }
    }
    return result;
}


        // asyncReduce
        /**
 * Asynchronously reduces an array to a single value using an async reducer function.
 * The reduction is performed sequentially, processing one item at a time.
 *
 * @param {Item[]} items - The array to reduce.
 * @param {function} reducer - Async function that combines the accumulator with each item.
 * @param {Result} initialResult - The initial value for the accumulator.
 * @returns {Promise<Result>} A promise that resolves to the final accumulated result.
 *
 * @example
 * ```ts
 * const numbers = [1, 2, 3, 4];
 * const sum = await asyncReduce(
 *   numbers,
 *   async (total, num) => {
 *     await sleep(100); // Simulate async operation
 *     return total + num;
 *   },
 *   0
 * );
 * // returns 10
 *
 * const words = ['hello', 'world'];
 * const combined = await asyncReduce(
 *   words,
 *   async (result, word) => result + ' ' + word,
 *   ''
 * );
 * // returns ' hello world'
 * ```
 */
async function asyncReduce(items, reducer, initialResult) {
    let result = initialResult;
    for (const item of items) {
        result = await reducer(result, item);
    }
    return result;
}


        // batchArray
        /**
 * Splits an array into smaller arrays (batches) of a specified size.
 * Each batch will contain at most `batchSize` items.
 *
 * @param {T[]} array - The array to split into batches.
 * @param {number} batchSize - The maximum number of items per batch.
 * @returns {T[][]} An array of arrays, where each sub-array is a batch.
 *
 * @example
 * ```ts
 * batchArray([1, 2, 3, 4, 5], 2);
 * // returns [[1, 2], [3, 4], [5]]
 *
 * batchArray(['a', 'b', 'c'], 3);
 * // returns [['a', 'b', 'c']]
 * ```
 */
function batchArray(array, batchSize) {
    return batchArrayByWeights(array, batchSize, () => 1);
}


        // batchArrayByWeights
        /**
 * Splits an array into smaller arrays (batches) based on weighted sizes.
 * Items are grouped into batches where the total weight doesn't exceed the specified batch size.
 *
 * @param {T[]} items - The array to split into batches.
 * @param {number} batchSize - The maximum total weight allowed per batch.
 * @param {function} getWeight - Function to calculate the weight of each item.
 * @returns {T[][]} An array of arrays, where each sub-array is a batch with total weight ‚â§ batchSize.
 *
 * @example
 * ```ts
 * const items = ['a', 'bb', 'ccc', 'dddd'];
 * batchArrayByWeights(items, 5, item => item.length);
 * // returns [['a', 'bb'], ['ccc'], ['dddd']]
 * // Batch 1: 'a' (1) + 'bb' (2) = 3 ‚â§ 5
 * // Batch 2: 'ccc' (3) = 3 ‚â§ 5
 * // Batch 3: 'dddd' (4) = 4 ‚â§ 5
 * ```
 */
function batchArrayByWeights(items, batchSize, getWeight) {
    const batches = [];
    let currentBatch = [];
    let weightInCurrentBatch = 0;
    for (const item of items) {
        const itemWeight = getWeight(item);
        if (weightInCurrentBatch + itemWeight > batchSize &&
            currentBatch.length > 0) {
            batches.push(currentBatch);
            currentBatch = [];
            weightInCurrentBatch = 0;
        }
        currentBatch.push(item);
        weightInCurrentBatch += itemWeight;
    }
    if (currentBatch.length > 0) {
        batches.push(currentBatch);
    }
    return batches;
}


        // batchAsyncIterableByWeights
        /**
 * Asynchronously splits an async iterable into batches based on weighted sizes.
 * Items are grouped into batches where the total weight doesn't exceed the specified batch size.
 * This is an async generator that yields batches as they are formed.
 *
 * @param {AsyncIterable<T>} items - The async iterable to split into batches.
 * @param {number} batchSize - The maximum total weight allowed per batch.
 * @param {function} getWeight - Function to calculate the weight of each item.
 * @yields {T[]} Arrays representing batches with total weight ‚â§ batchSize.
 *
 * @example
 * ```ts
 * async function* generateItems() {
 *   yield 'a'; yield 'bb'; yield 'ccc'; yield 'dddd';
 * }
 *
 * for await (const batch of batchAsyncIterableByWeights(generateItems(), 5, item => item.length)) {
 *   console.log(batch);
 * }
 * // Outputs: ['a', 'bb'], ['ccc'], ['dddd']
 * ```
 */
async function* batchAsyncIterableByWeights(items, batchSize, getWeight) {
    let currentBatch = [];
    let weightInCurrentBatch = 0;
    for await (const item of items) {
        const itemWeight = getWeight(item);
        if (weightInCurrentBatch + itemWeight > batchSize &&
            currentBatch.length > 0) {
            yield currentBatch;
            currentBatch = [];
            weightInCurrentBatch = 0;
        }
        currentBatch.push(item);
        weightInCurrentBatch += itemWeight;
    }
    if (currentBatch.length > 0) {
        yield currentBatch;
    }
}


        // groupBy
        /**
 * Groups the elements of an array based on a key derived from each element.
 * @param {T[]} array - The array to be grouped.
 * @param {function} getKey - A function that derives the key from each element.
 * @param {Record<Key, T[]>} initialValue - An initial value for the grouped result.
 * @returns {Record<Key, T[]>} An object where each key maps to an array of elements that share that key.
 * @example
 * const data = [
 *   { category: 'fruit', name: 'apple' },
 *   { category: 'vegetable', name: 'carrot' },
 *   { category: 'fruit', name: 'banana' },
 * ];
 * const grouped = groupBy(data, item => item.category, {});
 * // Result:
 * // {
 * //   fruit: [
 * //     { category: 'fruit', name: 'apple' },
 * //     { category: 'fruit', name: 'banana' },
 * //   ],
 * //   vegetable: [
 * //     { category: 'vegetable', name: 'carrot' },
 * //   ],
 * // };
 */
function groupBy(array, getKey, initialValue) {
    return array.reduce((acc, item) => {
        const key = getKey(item);
        if (!acc[key]) {
            acc[key] = [];
        }
        // Only clone if we're about to modify an array from initialValue
        if (initialValue[key] && acc[key] === initialValue[key]) {
            acc[key] = [...acc[key]];
        }
        acc[key].push(item);
        return acc;
    }, { ...initialValue });
}


        // pluckIds
        /**
 * Extracts unique IDs from an array of objects using an ID getter function.
 * The function flattens nested arrays up to 10 levels deep, filters out null/undefined values,
 * and returns a deduplicated array of IDs.
 *
 * @param {T[]} items - The array of objects to extract IDs from.
 * @param {function} idGetter - Function that extracts the ID(s) from each item. Can return single values or nested arrays.
 * @returns {Array} An array of unique, non-null IDs.
 *
 * @example
 * ```ts
 * const users = [
 *   { id: 1, friendIds: [2, 3] },
 *   { id: 2, friendIds: [1] },
 *   { id: 3, friendIds: [1, 2] }
 * ];
 *
 * // Extract user IDs
 * pluckIds(users, user => user.id);
 * // returns [1, 2, 3]
 *
 * // Extract friend IDs (flattened and deduplicated)
 * pluckIds(users, user => user.friendIds);
 * // returns [2, 3, 1]
 *
 * // Extract both user ID and friend IDs
 * pluckIds(users, user => [user.id, user.friendIds]);
 * // returns [1, 2, 3]
 * ```
 */
function pluckIds(items, idGetter) {
    const ids = items.map(idGetter).flat(10).filter(isDefined);
    return [...new Set(ids)];
}


        // roundToDecimals
        /**
 *
 * @param {number} value - The value to round.
 * @param {number} decimals - The number of decimal places to round to.
 * @returns {number} The rounded value.
 *
 * @example
 * ```ts
 * roundToDecimals(3.14159, 2); // returns 3.14
 * roundToDecimals(3.14159, 0); // returns 3
 * roundToDecimals(3.14159, 3); // returns 3.142
 * roundToDecimals(3.14, 5); // returns 3.14
 * ```
 */
function roundToDecimals(value, decimals) {
    const factor = Math.pow(10, decimals);
    return Math.round(value * factor) / factor;
}


        // stringToNumber
        /**
 * Safely converts a string to a number with validation.
 * Throws an error if the string cannot be converted to a valid finite number.
 *
 * @param {string} value - The string to convert to a number.
 * @returns {number} The parsed number.
 * @throws {Error} When the string is empty, not a number, or represents an infinite value.
 *
 * @example
 * ```ts
 * stringToNumber('123'); // returns 123
 * stringToNumber('3.14'); // returns 3.14
 * stringToNumber('-42'); // returns -42
 * stringToNumber('abc'); // throws Error: Invalid number: abc
 * stringToNumber(''); // throws Error: Invalid number:
 * stringToNumber('Infinity'); // throws Error: Invalid number: Infinity
 * ```
 */
function stringToNumber(value) {
    if (value.trim() === '') {
        throw new Error('Invalid number: empty string');
    }
    const parsedValue = Number(value);
    if (isNaN(parsedValue) || !isFinite(parsedValue)) {
        throw new Error(`Invalid number: ${value}`);
    }
    return parsedValue;
}


        // toSorted
        /**
 * Sorts an array by a key extracted from each item, returning a new sorted array.
 * The original array is not modified.
 *
 * @param {T[]} array - The array to sort.
 * @param {function} getKey - Function to extract the sort key from each item.
 * @param {string} order - Sort order, either 'asc' for ascending or 'desc' for descending. Defaults to 'asc'.
 * @returns {T[]} A new array with the same items sorted by the specified key and order.
 *
 * @example
 * ```ts
 * const users = [{ name: 'John', age: 30 }, { name: 'Jane', age: 25 }];
 *
 * // Sort by name ascending
 * toSorted(users, user => user.name);
 * // returns [{ name: 'Jane', age: 25 }, { name: 'John', age: 30 }]
 *
 * // Sort by age descending
 * toSorted(users, user => user.age, 'desc');
 * // returns [{ name: 'John', age: 30 }, { name: 'Jane', age: 25 }]
 * ```
 */
function toSorted(array, getKey, order = 'asc') {
    return array.toSorted((a, b) => {
        const keyA = getKey(a);
        const keyB = getKey(b);
        if (keyA < keyB) {
            return order === 'asc' ? -1 : 1;
        }
        if (keyA > keyB) {
            return order === 'asc' ? 1 : -1;
        }
        return 0;
    });
}


        // createRange
        /**
 * Creates an array of consecutive integers from 0 to length-1.
 *
 * @param {number} length - The number of elements in the range. Must be non-negative.
 * @returns {number[]} An array of integers from 0 to length-1.
 * @throws {Error} If length is negative.
 *
 * @example
 * ```ts
 * createRange(5); // returns [0, 1, 2, 3, 4]
 * createRange(0); // returns []
 * createRange(-1); // throws Error
 * ```
 */
function createRange(length) {
    if (length < 0) {
        throw new Error('Length must be a non-negative number');
    }
    if (!Number.isInteger(length)) {
        throw new Error('Length must be an integer');
    }
    return Array.from({ length }, (_, i) => i);
}


        // createSingletonAsync - source not found

        // createSingletonSync - source not found

        // callInOrderWithErrorHandling - source not found

        // createSubject
        /**
 * Calls all handlers in order, collecting errors and throwing them at the end.
 * If only one error occurs, throws that error directly.
 * If multiple errors occur, throws an AggregateError.
 *
 * @param {Set<Handler<TParams>>} handlers - Set of handler functions to call.
 * @param {TParams} params - Parameters to pass to each handler.
 * @throws {Error} The single error if only one handler fails.
 * @throws {AggregateError} If multiple handlers fail.
 */
async function callInOrderWithErrorHandling(handlers, params) {
    const errors = [];
    for (const handler of handlers) {
        try {
            await handler(params);
        }
        catch (error) {
            errors.push(error);
        }
    }
    if (errors.length > 0) {
        if (errors.length === 1) {
            throw firstOrThrow(errors);
        }
        throw new AggregateError(errors, 'Some handlers failed');
    }
}
/**
 * Creates a subject (observable) for event-driven programming.
 * Allows subscribers to listen for events and emit events to all subscribers.
 * Handlers are called in order, and all handlers are executed even if some fail.
 *
 * @returns {Object} An object with subscribe and emit methods.
 *
 * @example
 * ```ts
 * const subject = createSubject<string>();
 *
 * // Subscribe to events
 * const unsubscribe = subject.subscribe(async (message) => {
 *   console.log('Received:', message);
 * });
 *
 * // Emit events to all subscribers
 * await subject.emit('Hello, world!');
 *
 * // Unsubscribe when done
 * unsubscribe();
 * ```
 */
function createSubject() {
    const listeners = new Set();
    return {
        subscribe: (handler) => {
            listeners.add(handler);
            return () => {
                listeners.delete(handler);
            };
        },
        emit: async (params) => {
            await callInOrderWithErrorHandling(listeners, params);
        },
    };
}
/**
 * Merges multiple subjects into a single subscribable subject.
 * A handler subscribed to the merged subject will receive events from all source subjects.
 * Note: The merged subject cannot emit events, only subscribe to them.
 *
 * @param {Array<Subject<THandlerParams>>} subjects - Array of subjects to merge.
 * @returns {Object} A merged subject with only a subscribe method (no emit).
 *
 * @example
 * ```ts
 * const subject1 = createSubject<string>();
 * const subject2 = createSubject<string>();
 *
 * const merged = mergeSubjects([subject1, subject2]);
 *
 * // Subscribe once to receive events from both subjects
 * merged.subscribe((message) => {
 *   console.log('Received from any subject:', message);
 * });
 *
 * await subject1.emit('From subject1');
 * await subject2.emit('From subject2');
 * // Both messages are received by the merged subscriber
 * ```
 */
function mergeSubjects(subjects) {
    return {
        subscribe: (handler) => {
            const unsubscribes = subjects.map((subject) => subject.subscribe(handler));
            return () => unsubscribes.forEach((unsubscribe) => unsubscribe());
        },
    };
}


        // mergeSubjects - source not found

        // filterObjectFields
        /**
 * Creates a new object containing only the entries that pass the filter function.
 * The filter function receives both the value and key for each entry.
 *
 * @param {Record<string, Value>} object - The object to filter.
 * @param {function} filter - Function that tests each value and key. Returns true to keep the entry.
 * @returns {Record<string, Value>} A new object with only the filtered entries.
 *
 * @example
 * ```ts
 * const scores = { alice: 85, bob: 92, charlie: 78, diana: 95 };
 * const highScores = filterObjectFields(scores, (score) => score >= 90);
 * // returns { bob: 92, diana: 95 }
 *
 * const startsWithD = filterObjectFields(scores, (_, key) => key.startsWith('d'));
 * // returns { diana: 95 }
 * ```
 */
function filterObjectFields(object, filter) {
    const filteredObject = {};
    for (const key in object) {
        if (filter(object[key], key)) {
            filteredObject[key] = object[key];
        }
    }
    return filteredObject;
}


        // mapObjectFields
        /**
 * Transforms an object by mapping over its key-value pairs.
 * The mapping function receives each key-value pair as a tuple and returns a new tuple.
 *
 * @param {Record<string, TMapped>} obj - The object to transform.
 * @param {function} mapFn - Function that maps each [key, value] tuple to a new [key, value] tuple.
 * @returns {Record<string, TResult>} A new object with transformed entries.
 *
 * @example
 * ```ts
 * const prices = { apple: 1, banana: 2, orange: 3 };
 * const doubled = mapObjectFields(prices, ([key, value]) => [key, value * 2]);
 * // returns { apple: 2, banana: 4, orange: 6 }
 *
 * const prefixed = mapObjectFields(prices, ([key, value]) => [`fruit_${key}`, value]);
 * // returns { fruit_apple: 1, fruit_banana: 2, fruit_orange: 3 }
 * ```
 */
function mapObjectFields(obj, mapFn) {
    return Object.fromEntries(Object.entries(obj).map(mapFn));
}


        // omit
        /**
 * Creates a new object by excluding specified keys from an existing object.
 * Returns a copy of the object without the omitted properties.
 *
 * @param {Object} obj - The source object to omit from.
 * @param {...string} keys - Keys to omit from the object. Can be provided as separate arguments or arrays.
 * @returns {Object} A new object without the specified keys.
 *
 * @example
 * ```ts
 * const user = { id: 1, name: 'John', email: 'john@example.com', password: 'secret' };
 * const publicUser = omit(user, 'password');
 * // returns { id: 1, name: 'John', email: 'john@example.com' }
 *
 * const minimal = omit(user, 'password', 'email');
 * // returns { id: 1, name: 'John' }
 * ```
 */
function omit(obj, ...keys) {
    const keySet = new Set(keys.flat());
    const result = {};
    for (const key in obj) {
        if (!keySet.has(key)) {
            result[key] = obj[key];
        }
    }
    return result;
}


        // pick
        /**
 * Creates a new object by picking specified keys from an existing object.
 * Only includes properties that exist in the source object.
 *
 * @param {Object} obj - The source object to pick from.
 * @param {Array} keys - Array of keys to pick from the object.
 * @returns {Object} A new object containing only the specified keys.
 *
 * @example
 * ```ts
 * const user = { id: 1, name: 'John', email: 'john@example.com', age: 30 };
 * const userSummary = pick(user, ['id', 'name']);
 * // returns { id: 1, name: 'John' }
 * ```
 */
function pick(obj, keys) {
    const result = {};
    for (const key of keys) {
        if (key in obj) {
            result[key] = obj[key];
        }
    }
    return result;
}


        function displayOutput(elementId, content, isError = false) {
            const element = document.getElementById(elementId);
            element.textContent = content;
            element.className = 'output ' + (isError ? 'error' : 'success');
        }

        // Test functions

        function test_isDeepEqual() {
            try {
                const a = document.getElementById('isDeepEqual-a').value;
                const b = document.getElementById('isDeepEqual-b').value;
                const result = isDeepEqual(a, b);
                if (result && typeof result.then === 'function') {
                    result.then(r => {
                        displayOutput('isDeepEqual-output', 
                            `Input: ${JSON.stringify({ a, b })}\nOutput: ${JSON.stringify(r)}`);
                    }).catch(e => {
                        displayOutput('isDeepEqual-output', `Error: ${e.message}`, true);
                    });
                } else {
                    displayOutput('isDeepEqual-output', 
                        `Input: ${JSON.stringify({ a, b })}\nOutput: ${JSON.stringify(result)}`);
                }
            } catch (e) {
                displayOutput('isDeepEqual-output', `Error: ${e.message}`, true);
            }
        }

        function test_createDependencyContainer() {
            displayOutput('createDependencyContainer-output', 
                'This function requires complex parameters. Please see the documentation and examples above.', false);
        }

        function test_getErrorMessage() {
            try {
                const error = document.getElementById('getErrorMessage-error').value;
                const result = getErrorMessage(error);
                if (result && typeof result.then === 'function') {
                    result.then(r => {
                        displayOutput('getErrorMessage-output', 
                            `Input: ${JSON.stringify({ error })}\nOutput: ${JSON.stringify(r)}`);
                    }).catch(e => {
                        displayOutput('getErrorMessage-output', `Error: ${e.message}`, true);
                    });
                } else {
                    displayOutput('getErrorMessage-output', 
                        `Input: ${JSON.stringify({ error })}\nOutput: ${JSON.stringify(result)}`);
                }
            } catch (e) {
                displayOutput('getErrorMessage-output', `Error: ${e.message}`, true);
            }
        }

        function test_filterUnique() {
            displayOutput('filterUnique-output', 
                'This function requires complex parameters. Please see the documentation and examples above.', false);
        }

        function test_isDefined() {
            try {
                const value = document.getElementById('isDefined-value').value;
                const result = isDefined(value);
                if (result && typeof result.then === 'function') {
                    result.then(r => {
                        displayOutput('isDefined-output', 
                            `Input: ${JSON.stringify({ value })}\nOutput: ${JSON.stringify(r)}`);
                    }).catch(e => {
                        displayOutput('isDefined-output', `Error: ${e.message}`, true);
                    });
                } else {
                    displayOutput('isDefined-output', 
                        `Input: ${JSON.stringify({ value })}\nOutput: ${JSON.stringify(result)}`);
                }
            } catch (e) {
                displayOutput('isDefined-output', `Error: ${e.message}`, true);
            }
        }

        function test_findOrThrow() {
            displayOutput('findOrThrow-output', 
                'This function requires complex parameters. Please see the documentation and examples above.', false);
        }

        function test_firstOrThrow() {
            try {
                const items = JSON.parse(document.getElementById('firstOrThrow-items').value);
                const result = firstOrThrow(items);
                if (result && typeof result.then === 'function') {
                    result.then(r => {
                        displayOutput('firstOrThrow-output', 
                            `Input: ${JSON.stringify({ items })}\nOutput: ${JSON.stringify(r)}`);
                    }).catch(e => {
                        displayOutput('firstOrThrow-output', `Error: ${e.message}`, true);
                    });
                } else {
                    displayOutput('firstOrThrow-output', 
                        `Input: ${JSON.stringify({ items })}\nOutput: ${JSON.stringify(result)}`);
                }
            } catch (e) {
                displayOutput('firstOrThrow-output', `Error: ${e.message}`, true);
            }
        }

        function test_indexOrThrow() {
            try {
                const items = JSON.parse(document.getElementById('indexOrThrow-items').value);
                const index = parseFloat(document.getElementById('indexOrThrow-index').value);
                const result = indexOrThrow(items, index);
                if (result && typeof result.then === 'function') {
                    result.then(r => {
                        displayOutput('indexOrThrow-output', 
                            `Input: ${JSON.stringify({ items, index })}\nOutput: ${JSON.stringify(r)}`);
                    }).catch(e => {
                        displayOutput('indexOrThrow-output', `Error: ${e.message}`, true);
                    });
                } else {
                    displayOutput('indexOrThrow-output', 
                        `Input: ${JSON.stringify({ items, index })}\nOutput: ${JSON.stringify(result)}`);
                }
            } catch (e) {
                displayOutput('indexOrThrow-output', `Error: ${e.message}`, true);
            }
        }

        function test_makeThrottled() {
            displayOutput('makeThrottled-output', 
                'This function requires complex parameters. Please see the documentation and examples above.', false);
        }

        function test_sleep() {
            try {
                const ms = parseFloat(document.getElementById('sleep-ms').value);
                const result = sleep(ms);
                if (result && typeof result.then === 'function') {
                    result.then(r => {
                        displayOutput('sleep-output', 
                            `Input: ${JSON.stringify({ ms })}\nOutput: ${JSON.stringify(r)}`);
                    }).catch(e => {
                        displayOutput('sleep-output', `Error: ${e.message}`, true);
                    });
                } else {
                    displayOutput('sleep-output', 
                        `Input: ${JSON.stringify({ ms })}\nOutput: ${JSON.stringify(result)}`);
                }
            } catch (e) {
                displayOutput('sleep-output', `Error: ${e.message}`, true);
            }
        }

        function test_asTuple() {
            try {
                const arr = document.getElementById('asTuple-arr').value;
                const result = asTuple(arr);
                if (result && typeof result.then === 'function') {
                    result.then(r => {
                        displayOutput('asTuple-output', 
                            `Input: ${JSON.stringify({ arr })}\nOutput: ${JSON.stringify(r)}`);
                    }).catch(e => {
                        displayOutput('asTuple-output', `Error: ${e.message}`, true);
                    });
                } else {
                    displayOutput('asTuple-output', 
                        `Input: ${JSON.stringify({ arr })}\nOutput: ${JSON.stringify(result)}`);
                }
            } catch (e) {
                displayOutput('asTuple-output', `Error: ${e.message}`, true);
            }
        }

        function test_asyncFlatMap() {
            displayOutput('asyncFlatMap-output', 
                'This function requires complex parameters. Please see the documentation and examples above.', false);
        }

        function test_asyncMap() {
            displayOutput('asyncMap-output', 
                'This function requires complex parameters. Please see the documentation and examples above.', false);
        }

        function test_asyncReduce() {
            displayOutput('asyncReduce-output', 
                'This function requires complex parameters. Please see the documentation and examples above.', false);
        }

        function test_batchArray() {
            try {
                const array = JSON.parse(document.getElementById('batchArray-array').value);
                const batchSize = parseFloat(document.getElementById('batchArray-batchSize').value);
                const result = batchArray(array, batchSize);
                if (result && typeof result.then === 'function') {
                    result.then(r => {
                        displayOutput('batchArray-output', 
                            `Input: ${JSON.stringify({ array, batchSize })}\nOutput: ${JSON.stringify(r)}`);
                    }).catch(e => {
                        displayOutput('batchArray-output', `Error: ${e.message}`, true);
                    });
                } else {
                    displayOutput('batchArray-output', 
                        `Input: ${JSON.stringify({ array, batchSize })}\nOutput: ${JSON.stringify(result)}`);
                }
            } catch (e) {
                displayOutput('batchArray-output', `Error: ${e.message}`, true);
            }
        }

        function test_batchArrayByWeights() {
            displayOutput('batchArrayByWeights-output', 
                'This function requires complex parameters. Please see the documentation and examples above.', false);
        }

        function test_batchAsyncIterableByWeights() {
            displayOutput('batchAsyncIterableByWeights-output', 
                'This function requires complex parameters. Please see the documentation and examples above.', false);
        }

        function test_groupBy() {
            displayOutput('groupBy-output', 
                'This function requires complex parameters. Please see the documentation and examples above.', false);
        }

        function test_pluckIds() {
            displayOutput('pluckIds-output', 
                'This function requires complex parameters. Please see the documentation and examples above.', false);
        }

        function test_roundToDecimals() {
            try {
                const value = parseFloat(document.getElementById('roundToDecimals-value').value);
                const decimals = parseFloat(document.getElementById('roundToDecimals-decimals').value);
                const result = roundToDecimals(value, decimals);
                if (result && typeof result.then === 'function') {
                    result.then(r => {
                        displayOutput('roundToDecimals-output', 
                            `Input: ${JSON.stringify({ value, decimals })}\nOutput: ${JSON.stringify(r)}`);
                    }).catch(e => {
                        displayOutput('roundToDecimals-output', `Error: ${e.message}`, true);
                    });
                } else {
                    displayOutput('roundToDecimals-output', 
                        `Input: ${JSON.stringify({ value, decimals })}\nOutput: ${JSON.stringify(result)}`);
                }
            } catch (e) {
                displayOutput('roundToDecimals-output', `Error: ${e.message}`, true);
            }
        }

        function test_stringToNumber() {
            try {
                const value = document.getElementById('stringToNumber-value').value;
                const result = stringToNumber(value);
                if (result && typeof result.then === 'function') {
                    result.then(r => {
                        displayOutput('stringToNumber-output', 
                            `Input: ${JSON.stringify({ value })}\nOutput: ${JSON.stringify(r)}`);
                    }).catch(e => {
                        displayOutput('stringToNumber-output', `Error: ${e.message}`, true);
                    });
                } else {
                    displayOutput('stringToNumber-output', 
                        `Input: ${JSON.stringify({ value })}\nOutput: ${JSON.stringify(result)}`);
                }
            } catch (e) {
                displayOutput('stringToNumber-output', `Error: ${e.message}`, true);
            }
        }

        function test_toSorted() {
            displayOutput('toSorted-output', 
                'This function requires complex parameters. Please see the documentation and examples above.', false);
        }

        function test_createRange() {
            try {
                const length = parseFloat(document.getElementById('createRange-length').value);
                const result = createRange(length);
                if (result && typeof result.then === 'function') {
                    result.then(r => {
                        displayOutput('createRange-output', 
                            `Input: ${JSON.stringify({ length })}\nOutput: ${JSON.stringify(r)}`);
                    }).catch(e => {
                        displayOutput('createRange-output', `Error: ${e.message}`, true);
                    });
                } else {
                    displayOutput('createRange-output', 
                        `Input: ${JSON.stringify({ length })}\nOutput: ${JSON.stringify(result)}`);
                }
            } catch (e) {
                displayOutput('createRange-output', `Error: ${e.message}`, true);
            }
        }

        function test_createSingletonAsync() {
            displayOutput('createSingletonAsync-output', 
                'This function requires complex parameters. Please see the documentation and examples above.', false);
        }

        function test_createSingletonSync() {
            displayOutput('createSingletonSync-output', 
                'This function requires complex parameters. Please see the documentation and examples above.', false);
        }

        function test_callInOrderWithErrorHandling() {
            try {
                const handlers = document.getElementById('callInOrderWithErrorHandling-handlers').value;
                const params = document.getElementById('callInOrderWithErrorHandling-params').value;
                const result = callInOrderWithErrorHandling(handlers, params);
                if (result && typeof result.then === 'function') {
                    result.then(r => {
                        displayOutput('callInOrderWithErrorHandling-output', 
                            `Input: ${JSON.stringify({ handlers, params })}\nOutput: ${JSON.stringify(r)}`);
                    }).catch(e => {
                        displayOutput('callInOrderWithErrorHandling-output', `Error: ${e.message}`, true);
                    });
                } else {
                    displayOutput('callInOrderWithErrorHandling-output', 
                        `Input: ${JSON.stringify({ handlers, params })}\nOutput: ${JSON.stringify(result)}`);
                }
            } catch (e) {
                displayOutput('callInOrderWithErrorHandling-output', `Error: ${e.message}`, true);
            }
        }

        function test_createSubject() {
            try {
                
                const result = createSubject();
                if (result && typeof result.then === 'function') {
                    result.then(r => {
                        displayOutput('createSubject-output', 
                            `Input: ${JSON.stringify({  })}\nOutput: ${JSON.stringify(r)}`);
                    }).catch(e => {
                        displayOutput('createSubject-output', `Error: ${e.message}`, true);
                    });
                } else {
                    displayOutput('createSubject-output', 
                        `Input: ${JSON.stringify({  })}\nOutput: ${JSON.stringify(result)}`);
                }
            } catch (e) {
                displayOutput('createSubject-output', `Error: ${e.message}`, true);
            }
        }

        function test_mergeSubjects() {
            try {
                const subjects = JSON.parse(document.getElementById('mergeSubjects-subjects').value);
                const result = mergeSubjects(subjects);
                if (result && typeof result.then === 'function') {
                    result.then(r => {
                        displayOutput('mergeSubjects-output', 
                            `Input: ${JSON.stringify({ subjects })}\nOutput: ${JSON.stringify(r)}`);
                    }).catch(e => {
                        displayOutput('mergeSubjects-output', `Error: ${e.message}`, true);
                    });
                } else {
                    displayOutput('mergeSubjects-output', 
                        `Input: ${JSON.stringify({ subjects })}\nOutput: ${JSON.stringify(result)}`);
                }
            } catch (e) {
                displayOutput('mergeSubjects-output', `Error: ${e.message}`, true);
            }
        }

        function test_filterObjectFields() {
            displayOutput('filterObjectFields-output', 
                'This function requires complex parameters. Please see the documentation and examples above.', false);
        }

        function test_mapObjectFields() {
            displayOutput('mapObjectFields-output', 
                'This function requires complex parameters. Please see the documentation and examples above.', false);
        }

        function test_omit() {
            try {
                const obj = JSON.parse(document.getElementById('omit-obj').value);
                const keys = document.getElementById('omit-keys').value;
                const result = omit(obj, keys);
                if (result && typeof result.then === 'function') {
                    result.then(r => {
                        displayOutput('omit-output', 
                            `Input: ${JSON.stringify({ obj, keys })}\nOutput: ${JSON.stringify(r)}`);
                    }).catch(e => {
                        displayOutput('omit-output', `Error: ${e.message}`, true);
                    });
                } else {
                    displayOutput('omit-output', 
                        `Input: ${JSON.stringify({ obj, keys })}\nOutput: ${JSON.stringify(result)}`);
                }
            } catch (e) {
                displayOutput('omit-output', `Error: ${e.message}`, true);
            }
        }

        function test_pick() {
            try {
                const obj = JSON.parse(document.getElementById('pick-obj').value);
                const keys = JSON.parse(document.getElementById('pick-keys').value);
                const result = pick(obj, keys);
                if (result && typeof result.then === 'function') {
                    result.then(r => {
                        displayOutput('pick-output', 
                            `Input: ${JSON.stringify({ obj, keys })}\nOutput: ${JSON.stringify(r)}`);
                    }).catch(e => {
                        displayOutput('pick-output', `Error: ${e.message}`, true);
                    });
                } else {
                    displayOutput('pick-output', 
                        `Input: ${JSON.stringify({ obj, keys })}\nOutput: ${JSON.stringify(result)}`);
                }
            } catch (e) {
                displayOutput('pick-output', `Error: ${e.message}`, true);
            }
        }
    </script>
</body>
</html>